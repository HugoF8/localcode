origem.cpp

#include <iostream>
#include <vector>
#include <cmath>
#include <iomanip>
#include <opencv2/opencv.hpp>
#include "vc.h"

constexpr double PI = 3.141592653589793;

// Converte cv::Mat → IVC
IVC* mat_to_ivc(const cv::Mat& src) {
    IVC* img = vc_image_new(src.cols, src.rows, 3, 255);
    std::memcpy(img->data, src.data, src.cols * src.rows * 3);
    return img;
}

// Converte IVC → cv::Mat
cv::Mat ivc_to_mat(IVC* img) {
    cv::Mat m(img->height, img->width, CV_8UC3);
    std::memcpy(m.data, img->data, img->width * img->height * 3);
    return m;
}

int main() {
    cv::VideoCapture cap("video1.mp4");
    if (!cap.isOpened()) {
        std::cerr << "Erro a abrir vídeo\n";
        return -1;
    }

    int W = (int)cap.get(cv::CAP_PROP_FRAME_WIDTH);
    int H = (int)cap.get(cv::CAP_PROP_FRAME_HEIGHT);
    int fps = (int)cap.get(cv::CAP_PROP_FPS);
    int delay = 1000 / fps;

    double escala_pixel_mm = 12.875 / 65.0;

    cv::Mat frame;
    while (cap.read(frame) && !frame.empty()) {
        // → Conversão BGR → HSV via vc_rgb_to_hsv
        IVC* ivc_bgr = mat_to_ivc(frame);
        IVC* ivc_hsv = vc_image_new(W, H, 3, 255);
        vc_rgb_to_hsv(ivc_bgr, ivc_hsv);
        cv::Mat hsv = ivc_to_mat(ivc_hsv);

        // → Conversão BGR → Gray via vc_rgb_to_gray
        IVC* ivc_gray = vc_image_new(W, H, 1, 255);
        vc_rgb_to_gray(ivc_bgr, ivc_gray);
        cv::Mat gray(H, W, CV_8UC1);
        std::memcpy(gray.data, ivc_gray->data, W * H);

        // Máscara VERMELHO
        IVC* mask_vermelho = vc_image_new(W, H, 1, 255);
        vc_hsv_segmentation(ivc_hsv, mask_vermelho, 0, 10, 100, 255, 100, 255);
        cv::Mat mascara_vermelho(H, W, CV_8UC1, mask_vermelho->data);

        // Máscara AMARELO
        IVC* mask_amarelo = vc_image_new(W, H, 1, 255);
        vc_hsv_segmentation(ivc_hsv, mask_amarelo, 20, 40, 100, 255, 100, 255);
        cv::Mat mascara_amarelo(H, W, CV_8UC1, mask_amarelo->data);

        // Filtra reflexos metálicos
        for (int y = 0; y < H; ++y) {
            for (int x = 0; x < W; ++x) {
                auto p = hsv.at<cv::Vec3b>(y, x);
                int h = p[0], s = p[1], v = p[2];
                bool metal = (s < 60 && v > 130) || (h >= 15 && h <= 45 && s > 100 && v > 80);
                if (!metal) gray.at<uchar>(y, x) = 0;
            }
        }

        // Aplica máscaras
        gray.setTo(0, mascara_vermelho);
        gray.setTo(0, mascara_amarelo);

        // Suaviza
        cv::GaussianBlur(gray, gray, cv::Size(9, 9), 2);

        // Detecção de círculos
        std::vector<cv::Vec3f> circles;
        cv::HoughCircles(gray, circles, cv::HOUGH_GRADIENT, 1.2, 60, 150, 50, 45, 100);

        IVC* ivc_rgb = mat_to_ivc(frame);

        struct A { int x, y, r; std::string t; double area, perimeter; };
        std::vector<A> annots;
        int totalCount = 0; double totalValue = 0.0;

        for (auto& c : circles) {
            int cx = cvRound(c[0]), cy = cvRound(c[1]), r_px = cvRound(c[2]);
            double r_mm = r_px * escala_pixel_mm;
            if (r_mm < 11.0 || r_mm > 18.5) continue;

            double area = PI * r_px * r_px;
            double per = 2 * PI * r_px;
            double circ = (4 * PI * area) / (per * per);
            if (circ < 0.75) continue;

            // Cria máscara circular
            cv::Mat mask_circ = cv::Mat::zeros(frame.size(), CV_8UC1);
            for (int yy = std::max(0, cy - r_px); yy < std::min(H, cy + r_px); ++yy)
                for (int xx = std::max(0, cx - r_px); xx < std::min(W, cx + r_px); ++xx)
                    if ((xx - cx) * (xx - cx) + (yy - cy) * (yy - cy) <= r_px * r_px)
                        mask_circ.at<uchar>(yy, xx) = 255;

            // Cor média e HSV do círculo
            cv::Scalar mb = cv::mean(frame, mask_circ);
            IVC* pix = vc_image_new(1, 1, 3, 255);
            pix->data[0] = (unsigned char)mb[0];
            pix->data[1] = (unsigned char)mb[1];
            pix->data[2] = (unsigned char)mb[2];
            IVC* pix_hsv = vc_image_new(1, 1, 3, 255);
            vc_rgb_to_hsv(pix, pix_hsv);
            cv::Vec3b hvv{ pix_hsv->data[0], pix_hsv->data[1], pix_hsv->data[2] };
            vc_image_free(pix); vc_image_free(pix_hsv);

            int h = hvv[0], s = hvv[1], v = hvv[2];
            if ((s > 120 && (h < 5 || h>170)) || s > 220 || v < 35) continue;

            // Classifica valor
            std::string tipo; double valor;
            if (r_mm < 11.6) { tipo = "1c";  valor = 0.01; }
            else if (r_mm < 12.4) { tipo = "2c";  valor = 0.02; }
            else if (r_mm < 13.4) { tipo = "5c";  valor = 0.05; }
            else if (r_mm < 14.2) { tipo = "10c"; valor = 0.10; }
            else if (r_mm < 15.1) { tipo = "20c"; valor = 0.20; }
            else if (r_mm < 15.9) { tipo = "50c"; valor = 0.50; }
            else if (r_mm < 16.8) { tipo = "1e";  valor = 1.00; }
            else { tipo = "2e";  valor = 2.00; }

            totalCount++; totalValue += valor;
            annots.push_back({ cx,cy,r_px,tipo,area,per });

            vc_draw_circle(ivc_rgb, cx, cy, r_px, 0, 255, 0);
            vc_draw_rectangle(ivc_rgb, cx - r_px, cy - r_px, cx + r_px, cy + r_px, 255, 255, 0);
            vc_draw_circle(ivc_rgb, cx, cy, 2, 255, 0, 255);
        }

        frame = ivc_to_mat(ivc_rgb);

        for (auto& a : annots) {
            std::ostringstream ss;
            ss << a.t << " A=" << std::fixed << std::setprecision(0) << a.area
                << " P=" << std::fixed << std::setprecision(0) << a.perimeter;
            cv::putText(frame, ss.str(), { a.x - a.r, a.y - a.r - 5 },
                cv::FONT_HERSHEY_SIMPLEX, 0.5, { 0,0,0 }, 2);
            cv::putText(frame, ss.str(), { a.x - a.r, a.y - a.r - 5 },
                cv::FONT_HERSHEY_SIMPLEX, 0.5, { 255,255,255 }, 1);
        }

        std::ostringstream ss;
        ss << "Total: " << totalCount
            << "  Valor: " << std::fixed << std::setprecision(2) << totalValue << " EUR";
        cv::putText(frame, ss.str(), { 10,30 },
            cv::FONT_HERSHEY_SIMPLEX, 1.0, { 0,0,0 }, 3);
        cv::putText(frame, ss.str(), { 10,30 },
            cv::FONT_HERSHEY_SIMPLEX, 1.0, { 255,255,255 }, 1);

        cv::imshow("Moedas Detetadas (Final)", frame);
        if (cv::waitKey(delay) == 'q') break;

        // Liberta IVCs
        vc_image_free(ivc_bgr);
        vc_image_free(ivc_hsv);
        vc_image_free(ivc_gray);
        vc_image_free(mask_vermelho);
        vc_image_free(mask_amarelo);
        vc_image_free(ivc_rgb);
    }

    cap.release();
    cv::destroyAllWindows();
    return 0;
}

vc.h:
#pragma once

#include <opencv2/opencv.hpp>

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ESTRUTURA DE UMA IMAGEM
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
typedef struct {
    unsigned char* data;
    int width, height;
    int channels;
    int levels;
    int bytesperline;
} IVC;

// Estrutura de blob
typedef struct {
    int x, y, w, h;
    double area;
    double perimeter;
    int x_centroid, y_centroid;
} Blob;

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// PROTÓTIPOS DE FUNÇÕES
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Alocação e libertação de imagem
IVC* vc_image_new(int width, int height, int channels, int levels);
IVC* vc_image_free(IVC* image);

// Conversão RGB -> HSV
int vc_rgb_to_hsv(IVC* src, IVC* dst);

// **Conversão RGB -> Gray**
int vc_rgb_to_gray(IVC* src, IVC* dst);

// Segmentação HSV
int vc_hsv_segmentation(IVC* src, IVC* dst,
    int hmin, int hmax,
    int smin, int smax,
    int vmin, int vmax);

// Morfologia
int vc_binary_dilate(IVC* src, IVC* dst, int kernel);
int vc_binary_erode(IVC* src, IVC* dst, int kernel);
int vc_binary_open(IVC* src, IVC* dst, int kernel);
int vc_binary_close(IVC* src, IVC* dst, int kernel);

// Etiquetagem e informação de blobs
int vc_binary_blob_labelling(IVC* src, IVC* dst);
Blob* vc_binary_blob_info(IVC* src, int* n);

// Desenho
int vc_draw_circle(IVC* image, int cx, int cy, int r, int R, int G, int B);
int vc_draw_rectangle(IVC* image, int x1, int y1, int x2, int y2, int R, int G, int B);

// Debug visual
cv::Mat vc_colorize_labels(IVC* dst, int n_blobs);

// Macros auxiliares
#define MAX3(a,b,c) (a > b ? (a > c ? a : c) : (b > c ? b: c))
#define MIN3(a,b,c) (a < b ? (a < c ? a : c) : (b < c ? b : c))

vc.cpp:#include "vc.h"
#include <vector>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <opencv2/opencv.hpp>

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

// Alocar imagem
IVC* vc_image_new(int width, int height, int channels, int levels) {
    IVC* image = (IVC*)malloc(sizeof(IVC));
    if (!image || levels <= 0 || levels > 255) return NULL;
    image->width = width;
    image->height = height;
    image->channels = channels;
    image->levels = levels;
    image->bytesperline = width * channels;
    image->data = (unsigned char*)malloc(width * height * channels);
    if (!image->data) return vc_image_free(image);
    return image;
}

// Libertar imagem
IVC* vc_image_free(IVC* image) {
    if (image) {
        free(image->data);
        free(image);
    }
    return NULL;
}

// Conversão RGB -> HSV
int vc_rgb_to_hsv(IVC* src, IVC* dst) {
    if (!src || !dst || src->channels != 3 || dst->channels != 3 ||
        src->width != dst->width || src->height != dst->height) return 0;

    for (int y = 0; y < src->height; y++) {
        for (int x = 0; x < src->width; x++) {
            int pos = y * src->bytesperline + x * 3;
            float r = src->data[pos + 2] / 255.0f;
            float g = src->data[pos + 1] / 255.0f;
            float b = src->data[pos + 0] / 255.0f;
            float mx = std::max({ r, g, b });
            float mn = std::min({ r, g, b });
            float delta = mx - mn;
            float h = 0.0f, s = 0.0f, v = mx;
            if (delta > 1e-6f) {
                if (mx == r) h = 60.0f * fmodf((g - b) / delta, 6.0f);
                else if (mx == g) h = 60.0f * (((b - r) / delta) + 2.0f);
                else h = 60.0f * (((r - g) / delta) + 4.0f);
                if (h < 0.0f) h += 360.0f;
                s = delta / mx;
            }
            dst->data[pos + 0] = (unsigned char)(h / 360.0f * 255.0f);
            dst->data[pos + 1] = (unsigned char)(s * 255.0f);
            dst->data[pos + 2] = (unsigned char)(v * 255.0f);
        }
    }
    return 1;
}

// Segmentação HSV
int vc_hsv_segmentation(IVC* src, IVC* dst, int hmin, int hmax, int smin, int smax, int vmin, int vmax) {
    if (!src || !dst || src->channels != 3 || dst->channels != 1 ||
        src->width != dst->width || src->height != dst->height) return 0;
    for (int y = 0; y < src->height; y++) {
        for (int x = 0; x < src->width; x++) {
            int ps = y * src->bytesperline + x * 3;
            unsigned char h = src->data[ps + 0];
            unsigned char s = src->data[ps + 1];
            unsigned char v = src->data[ps + 2];
            dst->data[y * dst->bytesperline + x] =
                (h >= hmin && h <= hmax && s >= smin && s <= smax && v >= vmin && v <= vmax) ? 255 : 0;
        }
    }
    return 1;
}

// Morfologia
int vc_binary_dilate(IVC* src, IVC* dst, int kernel) {
    int k = kernel / 2;
    memset(dst->data, 0, src->width * src->height);
    for (int y = k; y < src->height - k; y++) {
        for (int x = k; x < src->width - k; x++) {
            if (src->data[y * src->bytesperline + x] == 255) {
                for (int j = -k; j <= k; j++)
                    for (int i = -k; i <= k; i++)
                        dst->data[(y + j) * dst->bytesperline + (x + i)] = 255;
            }
        }
    }
    return 1;
}

int vc_binary_erode(IVC* src, IVC* dst, int kernel) {
    int k = kernel / 2;
    memset(dst->data, 0, src->width * src->height);
    for (int y = k; y < src->height - k; y++) {
        for (int x = k; x < src->width - k; x++) {
            bool all_white = true;
            for (int j = -k; j <= k && all_white; j++)
                for (int i = -k; i <= k; i++)
                    if (src->data[(y + j) * src->bytesperline + (x + i)] != 255)
                        all_white = false;
            if (all_white)
                dst->data[y * dst->bytesperline + x] = 255;
        }
    }
    return 1;
}

int vc_binary_open(IVC* src, IVC* dst, int kernel) {
    IVC* temp = vc_image_new(src->width, src->height, 1, src->levels);
    if (!temp) return 0;
    int ok = vc_binary_erode(src, temp, kernel) && vc_binary_dilate(temp, dst, kernel);
    vc_image_free(temp);
    return ok;
}

int vc_binary_close(IVC* src, IVC* dst, int kernel) {
    IVC* temp = vc_image_new(src->width, src->height, 1, src->levels);
    if (!temp) return 0;
    int ok = vc_binary_dilate(src, temp, kernel) && vc_binary_erode(temp, dst, kernel);
    vc_image_free(temp);
    return ok;
}

// Etiquetagem de blobs (simplificada)
int vc_binary_blob_labelling(IVC* src, IVC* dst) {
    if (!src || !dst || src->channels != 1 || dst->channels != 1 ||
        src->width != dst->width || src->height != dst->height) return 0;

    int W = src->width;
    int H = src->height;
    int label = 1;

    std::vector<int> labels(W * H, 0);
    memcpy(dst->data, src->data, W * H);

    for (int y = 0; y < H; y++) {
        for (int x = 0; x < W; x++) {
            int i = y * W + x;
            if (src->data[i] == 255 && labels[i] == 0) {
                std::vector<std::pair<int, int>> queue = { {x, y} };
                while (!queue.empty()) {
                    int cx = queue.back().first;
                    int cy = queue.back().second;
                    queue.pop_back();
                    int ci = cy * W + cx;

                    if (cx < 0 || cx >= W || cy < 0 || cy >= H)
                        continue;
                    if (src->data[cy * W + cx] != 255 || labels[cy * W + cx] != 0)
                        continue;

                    labels[cy * W + cx] = label;

                    for (int j = -1; j <= 1; j++) {
                        for (int i = -1; i <= 1; i++) {
                            int nx = cx + i;
                            int ny = cy + j;
                            if (nx >= 0 && nx < W && ny >= 0 && ny < H)
                                queue.push_back({ nx, ny });
                        }
                    }
                }
                label++;
            }
        }
    }

    for (int i = 0; i < W * H; i++) {
        dst->data[i] = (unsigned char)(labels[i] > 0 ? labels[i] : 0);
    }

    return label - 1;
}


// Info dos blobs
Blob* vc_binary_blob_info(IVC* src, int* n) {
    int W = src->width, H = src->height;
    Blob* blobs = (Blob*)calloc(*n, sizeof(Blob));
    int* area = (int*)calloc(*n, sizeof(int));
    int* sumX = (int*)calloc(*n, sizeof(int));
    int* sumY = (int*)calloc(*n, sizeof(int));

    for (int i = 0; i < *n; i++) {
        blobs[i].x = W; blobs[i].y = H;
    }

    for (int y = 0; y < H; y++) {
        for (int x = 0; x < W; x++) {
            int label = src->data[y * W + x];
            if (label > 0 && label <= *n) {
                int i = label - 1;
                area[i]++;
                sumX[i] += x;
                sumY[i] += y;
                if (x < blobs[i].x) blobs[i].x = x;
                if (y < blobs[i].y) blobs[i].y = y;
                if (x > blobs[i].x + blobs[i].w) blobs[i].w = x - blobs[i].x;
                if (y > blobs[i].y + blobs[i].h) blobs[i].h = y - blobs[i].y;
            }
        }
    }

    for (int i = 0; i < *n; i++) {
        blobs[i].area = area[i];
        blobs[i].x_centroid = sumX[i] / area[i];
        blobs[i].y_centroid = sumY[i] / area[i];
    }

    free(area); free(sumX); free(sumY);
    return blobs;
}

// Desenho
int vc_draw_circle(IVC* image, int cx, int cy, int r, int R, int G, int B) {
    for (double t = 0; t < 2 * M_PI; t += 0.01) {
        int x = cx + r * cos(t);
        int y = cy + r * sin(t);
        if (x >= 0 && x < image->width && y >= 0 && y < image->height) {
            int pos = y * image->bytesperline + x * 3;
            image->data[pos + 0] = B;
            image->data[pos + 1] = G;
            image->data[pos + 2] = R;
        }
    }
    return 1;
}

int vc_draw_rectangle(IVC* image, int x1, int y1, int x2, int y2, int R, int G, int B) {
    for (int x = x1; x <= x2; x++) {
        if (y1 >= 0 && y1 < image->height && x >= 0 && x < image->width) {
            int i = (y1 * image->width + x) * 3;
            image->data[i] = B; image->data[i + 1] = G; image->data[i + 2] = R;
        }
        if (y2 >= 0 && y2 < image->height && x >= 0 && x < image->width) {
            int i = (y2 * image->width + x) * 3;
            image->data[i] = B; image->data[i + 1] = G; image->data[i + 2] = R;
        }
    }
    for (int y = y1; y <= y2; y++) {
        if (x1 >= 0 && x1 < image->width && y >= 0 && y < image->height) {
            int i = (y * image->width + x1) * 3;
            image->data[i] = B; image->data[i + 1] = G; image->data[i + 2] = R;
        }
        if (x2 >= 0 && x2 < image->width && y >= 0 && y < image->height) {
            int i = (y * image->width + x2) * 3;
            image->data[i] = B; image->data[i + 1] = G; image->data[i + 2] = R;
        }
    }
    return 1;
}

// Colorização para debug
cv::Mat vc_colorize_labels(IVC* dst, int n_blobs) {
    int W = dst->width, H = dst->height;
    cv::Mat out(H, W, CV_8UC3);
    std::vector<cv::Vec3b> palette(n_blobs + 1);
    palette[0] = cv::Vec3b(0, 0, 0);
    cv::RNG rng(12345);
    for (int i = 1; i <= n_blobs; i++) {
        palette[i] = cv::Vec3b(rng.uniform(50, 255), rng.uniform(50, 255), rng.uniform(50, 255));
    }
    for (int y = 0; y < H; y++) {
        for (int x = 0; x < W; x++) {
            int lbl = dst->data[y * dst->bytesperline + x];
            out.at<cv::Vec3b>(y, x) = palette[lbl];
        }
    }
    return out;
}

int vc_rgb_to_gray(IVC* src, IVC* dst) {
    if (!src || !dst || src->channels != 3 || dst->channels != 1 ||
        src->width != dst->width || src->height != dst->height) return 0;

    for (int y = 0; y < src->height; y++) {
        for (int x = 0; x < src->width; x++) {
            int pos = y * src->bytesperline + x * 3;
            unsigned char b = src->data[pos + 0];
            unsigned char g = src->data[pos + 1];
            unsigned char r = src->data[pos + 2];
            unsigned char gray = static_cast<unsigned char>(
                0.114f * b + 0.587f * g + 0.299f * r
                );
            dst->data[y * dst->bytesperline + x] = gray;
        }
    }
    return 1;
}