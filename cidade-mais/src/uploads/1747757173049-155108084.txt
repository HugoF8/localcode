cql_eval.py

import csv
from cql_grammar import *
from collections import OrderedDict

def carregar_csv(filename):
    try:
        with open(filename, encoding='utf-8') as f:
            lines = [
                l.strip() for l in f
                if l.strip() and not l.strip().startswith('--')
                       and not l.strip().startswith('{-')
            ]
        reader = csv.reader(lines)
        headers = next(reader)
        return [dict(zip(headers, row)) for row in reader]
    except Exception as e:
        print(f"Erro ao carregar o ficheiro CSV {filename}: {e}")
        return []

def salvar_csv(filename, data):
    if not data:
        print(f"{filename}: sem dados para guardar.")
        return
    headers = list(data[0].keys())
    with open(filename, 'w', newline='', encoding='utf-8') as f:
        writer = csv.writer(f)
        writer.writerow(headers)
        for row in data:
            writer.writerow([row.get(h, "") for h in headers])

def juntar_tabelas(t1, t2, col):
    result = []
    for r1 in t1:
        for r2 in t2:
            if r1.get(col) == r2.get(col):
                merged = OrderedDict(r1)
                merged.update(r2)
                result.append(dict(merged))
    return result

class Memory:
    def __init__(self):
        self.tables = {}
        self.procs = {}

    def store_table(self, name, data):
        self.tables[name] = data

    def get_table(self, name):
        return self.tables.get(name)

    def discard_table(self, name):
        return self.tables.pop(name, None) is not None

    def rename_table(self, old, new):
        if old in self.tables:
            self.tables[new] = self.tables.pop(old)
            return True
        return False

    def list_tables(self):
        return list(self.tables.keys())

    def store_proc(self, name, stmts):
        self.procs[name] = stmts

    def get_proc(self, name):
        return self.procs.get(name)

class Evaluator:
    def __init__(self, mem=None):
        self.mem = mem or Memory()

    def visit(self, node):
        method = f"visit_{type(node).__name__}"
        return getattr(self, method)(node)

    def visit_ProgramNode(self, node):
        for stmt in node.statements:
            self.visit(stmt)

    def visit_ImportTableNode(self, node):
        data = carregar_csv(node.filename)
        self.mem.store_table(node.name, data)
        print(f"Tabela '{node.name}' importada ({len(data)} linhas).")

    def visit_ExportTableNode(self, node):
        data = self.mem.get_table(node.name)
        salvar_csv(node.filename, data)
        print(f"Tabela '{node.name}' exportada para '{node.filename}'.")

    def visit_DiscardTableNode(self, node):
        ok = self.mem.discard_table(node.name)
        print("Descartada." if ok else "Não encontrada.")

    def visit_RenameTableNode(self, node):
        ok = self.mem.rename_table(node.old, node.new)
        print("Renomeada." if ok else "Falhou.")

    def visit_PrintTableNode(self, node):
        data = self.mem.get_table(node.name) or []
        self._print_result(data, f"Tabela: {node.name}")

    def visit_SelectNode(self, node):
        tbl = self.mem.get_table(node.table) or []
        rows = tbl
        if node.where:
            rows = [r for r in rows if self._check(r, node.where)]
        if node.columns != ['*']:
            rows = [ {c: r.get(c) for c in node.columns} for r in rows ]
        if node.limit:
            rows = rows[:node.limit.count]
        self._print_result(rows, f"SELECT de '{node.table}'")
        return rows

    def visit_CreateTableNode(self, node):
        src = node.source
        if isinstance(src, SelectNode):
            rows = self.visit(src)
        elif isinstance(src, JoinTableNode):
            left_tbl  = self.mem.get_table(src.left)  or []
            right_tbl = self.mem.get_table(src.right) or []
            rows = juntar_tabelas(left_tbl, right_tbl, src.column)
        else:
            rows = self.mem.get_table(src) or []
        self.mem.store_table(node.name, rows)
        print(f"Tabela '{node.name}' criada ({len(rows)} linhas).")

    def visit_ProcedureNode(self, node):
        self.mem.store_proc(node.name, node.statements)
        print(f"Procedimento '{node.name}' guardado.")

    def visit_CallProcedureNode(self, node):
        stmts = self.mem.get_proc(node.name) or []
        for s in stmts:
            self.visit(s)

    def _check(self, row, cond):
        lv = row.get(cond.left)
        rv = cond.right
        op = cond.op
        try:
            if op == '=':  return lv == rv
            if op == '<>': return lv != rv
            if op == '>':  return float(lv) > float(rv)
            if op == '<':  return float(lv) < float(rv)
            if op == '>=': return float(lv) >= float(rv)
            if op == '<=': return float(lv) <= float(rv)
            if op == 'AND':
                return self._check(row, cond.left) and self._check(row, cond.right)
        except:
            return False
        return False

    def _print_result(self, data, title="Resultado"):
        if not data:
            print(f"{title}: Sem resultados.")
            return
        columns = list(data[0].keys())
        header = " | ".join(columns)
        separator = "-" * len(header)
        print(f"\n{title}")
        print(separator)
        print(header)
        print(separator)
        for row in data:
            values = [str(row.get(c, "")) for c in columns]
            print(" | ".join(values))
        print(separator)
        print(f"Total: {len(data)} linhas\n")


-------------------------------------------------
cql_grammar.py

from ply import yacc
from cql_lexer import CQLLexer


# Árvore Sintática Abstrata
class ASTNode:
    pass

class ProgramNode(ASTNode):
    def __init__(self, statements):
        self.statements = statements

class ImportTableNode(ASTNode):
    def __init__(self, name, filename):
        self.name = name
        self.filename = filename

class ExportTableNode(ASTNode):
    def __init__(self, name, filename):
        self.name = name
        self.filename = filename

class DiscardTableNode(ASTNode):
    def __init__(self, name):
        self.name = name

class RenameTableNode(ASTNode):
    def __init__(self, old, new):
        self.old = old
        self.new = new

class PrintTableNode(ASTNode):
    def __init__(self, name):
        self.name = name

class SelectNode(ASTNode):
    def __init__(self, columns, table, where, limit):
        self.columns = columns
        self.table = table
        self.where = where
        self.limit = limit

class ConditionNode(ASTNode):
    def __init__(self, left, op, right):
        self.left = left
        self.op = op
        self.right = right

class LimitNode(ASTNode):
    def __init__(self, count):
        self.count = count

class CreateTableNode(ASTNode):
    def __init__(self, name, source):
        self.name = name
        self.source = source

class JoinTableNode(ASTNode):
    def __init__(self, left, right, column):
        self.left = left
        self.right = right
        self.column = column

class ProcedureNode(ASTNode):
    def __init__(self, name, statements):
        self.name = name
        self.statements = statements

class CallProcedureNode(ASTNode):
    def __init__(self, name):
        self.name = name


# Gramática
class CQLGrammar:
    tokens = CQLLexer.tokens

    def __init__(self):
        self.lexer = CQLLexer()
        self.lexer.build()
        self.parser = yacc.yacc(module=self)

    # Programa
    def p_program(self, p):
        "program : statements"
        p[0] = ProgramNode(p[1])

    def p_statements(self, p):
        """statements : statements statement
                      | statement"""
        if len(p) == 3:
            p[0] = p[1] + [p[2]]
        else:
            p[0] = [p[1]]

    # Statements
    def p_statement_import(self, p):
        "statement : IMPORT TABLE IDENTIFIER FROM STRING SEMICOLON"
        p[0] = ImportTableNode(p[3], p[5])

    def p_statement_export(self, p):
        "statement : EXPORT TABLE IDENTIFIER AS STRING SEMICOLON"
        p[0] = ExportTableNode(p[3], p[5])

    def p_statement_discard(self, p):
        "statement : DISCARD TABLE IDENTIFIER SEMICOLON"
        p[0] = DiscardTableNode(p[3])

    def p_statement_rename(self, p):
        "statement : RENAME TABLE IDENTIFIER IDENTIFIER SEMICOLON"
        p[0] = RenameTableNode(p[3], p[4])

    def p_statement_print(self, p):
        "statement : PRINT TABLE IDENTIFIER SEMICOLON"
        p[0] = PrintTableNode(p[3])

    def p_statement_select(self, p):
        "statement : SELECT select_columns FROM IDENTIFIER where_clause limit_clause SEMICOLON"
        p[0] = SelectNode(p[2], p[4], p[5], p[6])

    def p_select_columns_asterisk(self, p):
        "select_columns : ASTERISK"
        p[0] = ['*']

    def p_select_columns_list(self, p):
        "select_columns : column_list"
        p[0] = p[1]

    def p_column_list(self, p):
        """column_list : IDENTIFIER
                       | column_list COMMA IDENTIFIER"""
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[1].append(p[3])
            p[0] = p[1]

    def p_where_clause(self, p):
        """where_clause : WHERE condition
                        | empty"""
        p[0] = p[2] if p[1] else None

    def p_condition(self, p):
        """condition : IDENTIFIER EQUALS value
                     | IDENTIFIER NOTEQUAL value
                     | IDENTIFIER GT value
                     | IDENTIFIER LT value
                     | IDENTIFIER GE value
                     | IDENTIFIER LE value
                     | condition AND condition"""
        if len(p) == 4 and isinstance(p[2], str):
            p[0] = ConditionNode(p[1], p[2], p[3])
        else:
            p[0] = ConditionNode(p[1], 'AND', p[3])

    def p_limit_clause(self, p):
        """limit_clause : LIMIT NUMBER
                        | empty"""
        p[0] = LimitNode(p[2]) if len(p) == 3 else None

    def p_value(self, p):
        """value : NUMBER
                 | STRING"""
        p[0] = p[1]

    def p_statement_create(self, p):
        """
        statement : CREATE TABLE IDENTIFIER select_source SEMICOLON
                  | CREATE TABLE IDENTIFIER SELECT select_columns FROM IDENTIFIER where_clause limit_clause SEMICOLON
        """
        # Se for a forma com SELECT inline
        if len(p) > 5 and p[4] == 'SELECT':
            cols   = p[5]
            table  = p[7]
            where  = p[8]
            limit  = p[9]
            p[0] = CreateTableNode(p[3], SelectNode(cols, table, where, limit))
        else:
            # Forma antiga: CREATE TABLE nome FROM ... (ou JOIN ...)
            p[0] = CreateTableNode(p[3], p[4])

    def p_select_source(self, p):
        """select_source : FROM IDENTIFIER
                         | FROM IDENTIFIER JOIN IDENTIFIER USING LPAREN IDENTIFIER RPAREN"""
        if len(p) == 3:
            p[0] = p[2]
        else:
            p[0] = JoinTableNode(p[2], p[4], p[7])

    def p_statement_procedure(self, p):
        """statement : PROCEDURE IDENTIFIER DO statements END
                  | PROCEDURE IDENTIFIER DO statements END SEMICOLON"""
        p[0] = ProcedureNode(p[2], p[4])

    def p_statement_call(self, p):
        "statement : CALL IDENTIFIER SEMICOLON"
        p[0] = CallProcedureNode(p[2])

    def p_empty(self, p):
        "empty :"
        p[0] = None

    def p_error(self, p):
        if p:
            raise SyntaxError(f"Sintaxe inválida: token {p.value!r} (tipo {p.type}) na linha {p.lineno}")
        else:
            raise SyntaxError("Sintaxe inválida no ficheiro")

    def parse(self, text):
        return self.parser.parse(text, lexer=self.lexer.lexer)


def create_parser():
    return CQLGrammar()

---------------------------------
cql_lexer.py

import ply.lex as lex
import re

class CQLLexer:

    # Lista de nomes de tokens
    tokens = [
        'IDENTIFIER',
        'STRING',
        'NUMBER',
        'SEMICOLON',
        'COMMA',
        'LPAREN',
        'RPAREN',
        'ASTERISK',
        'EQUALS',
        'NOTEQUAL',
        'GT',
        'LT',
        'GE',
        'LE',
        'DOT',
        'AND',
    ]

    # Lista de palavras reservadas
    reserved = {
        'import': 'IMPORT',
        'export': 'EXPORT',
        'table': 'TABLE',
        'from': 'FROM',
        'as': 'AS',
        'call': 'CALL',
        'discard': 'DISCARD',
        'rename': 'RENAME',
        'print': 'PRINT',
        'select': 'SELECT',
        'where': 'WHERE',
        'limit': 'LIMIT',
        'create': 'CREATE',
        'join': 'JOIN',
        'using': 'USING',
        'procedure': 'PROCEDURE',
        'do': 'DO',
        'end': 'END',
        'and': 'AND',  # <- adiciona "and" às palavras reservadas
    }

    # Junta os tokens das palavras reservadas
    tokens = tokens + list(reserved.values())

    # Definições de expressões regulares para tokens simples
    t_SEMICOLON = r';'
    t_COMMA     = r','
    t_LPAREN    = r'\('
    t_RPAREN    = r'\)'
    t_ASTERISK  = r'\*'
    t_EQUALS    = r'='
    t_NOTEQUAL  = r'<>'
    t_GT        = r'>'
    t_LT        = r'<'
    t_GE        = r'>='
    t_LE        = r'<='
    t_DOT       = r'\.'

    # Ignorar espaços, tabs, quebras de linha e \r (Windows)
    t_ignore = ' \t\n\r'

    # Comentário de linha
    def t_COMMENT_SINGLE(self, t):
        r'--[^\n\r]*'
        pass

    # Comentário multilinha
    def t_COMMENT_MULTI(self, t):
        r'{-[\s\S]*?-}'
        pass

    def t_STRING(self, t):
        r'\"([^\\\"]|(\\.))*\"'
        t.value = t.value[1:-1]
        return t

    def t_NUMBER(self, t):
        r'\d+(\.\d+)?'
        t.value = float(t.value) if '.' in t.value else int(t.value)
        return t

    def t_IDENTIFIER(self, t):
        r'[A-Za-z_][A-Za-z0-9_]*'
        t.type = self.reserved.get(t.value.lower(), 'IDENTIFIER')
        return t

    def t_error(self, t):
        raise SyntaxError(f"Caracter Invalido: {t.value[0]!r}")

    def build(self, **kwargs):
        self.lexer = lex.lex(module=self, **kwargs)
        return self.lexer

    def input(self, data):
        self.lexer.input(data)

    def get_tokens(self, data):
        self.input(data)
        toks = []
        while True:
            tok = self.lexer.token()
            if not tok:
                break
            toks.append(tok)
        return toks


def create_lexer():
    return CQLLexer().build()


def test_lexer():
    data = """
    -- Comentário de linha
    IMPORT TABLE estacoes FROM "estacoes.csv";
    SELECT * FROM observacoes WHERE Temperatura > 22 AND Radiacao > 100;
    {- Comentário
       multilinha -}
    """
    lex = create_lexer()
    for tok in lex.input(data) or []:
        print(tok)


if __name__ == "__main__":
    test_lexer()

---------------------------------
main.py

import sys
import os
from cql_grammar import create_parser, ImportTableNode, PrintTableNode
from cql_eval    import Evaluator, Memory

def print_header():
    print("="*60)
    print(" CQL Interpreter ")
    print("="*60)

def print_help():
    print(":help    mostrar esta ajuda")
    print(":quit    sair")
    print()

def run_file(fname, parser, evaluator):
    with open(fname, encoding='utf-8') as f:
        script = f.read()
    prog = parser.parse(script)
    evaluator.visit(prog)

def run_datafile(fname, parser, evaluator):
    name, _ = os.path.splitext(os.path.basename(fname))
    print(f"Importando '{fname}' → tabela '{name}'")
    evaluator.visit(ImportTableNode(name, fname))
    evaluator.visit(PrintTableNode(name))

def repl(parser, evaluator):
    print_header()
    print("Escreva comandos CQL (‘:help’ para ajuda, ‘:quit’ para sair)\n")
    while True:
        try:
            line = input("cql> ").strip()
        except EOFError:
            break
        if not line:
            continue
        if line.startswith(':'):
            if line in (':quit', ':exit'):
                break
            if line == ':help':
                print_help()
            continue

        stmt = line if line.endswith(';') else line + ';'
        prog = parser.parse(stmt)
        evaluator.visit(prog)

def main():
    parser    = create_parser()
    memory    = Memory()
    evaluator = Evaluator(memory)

    if len(sys.argv) > 1:
        arg = sys.argv[1]
        ext = os.path.splitext(arg)[1].lower()

        if ext == '.csv' and os.path.isfile(arg):
            run_datafile(arg, parser, evaluator)
        else:

            run_file(arg, parser, evaluator)
    else:
        repl(parser, evaluator)

if __name__ == "__main__":
    main()

----------------------------------
pasta data

estacoes.csv
Id,Local,Coordenadas
E1,Terras de Bouro/Barral (CIM),"[-8.31808611,41.70225278]"
E2,Graciosa / Serra das Fontes (DROTRH),"[-28.0038,39.0672]"
E3,"Olhão, EPPO","[-7.821,37.033]"
E4,"Setúbal, Areias","[-8.89066111,38.54846667]"



observacoes.csv
Id,IntensidadeVentoKM,Temperatura,Radiacao,DirecaoVento,IntensidadeVento,Humidade,DataHoraObservacao
E1,2.5,23.2,133.2,NE,0.7,58.0,2025-04-10T19:00
E2,15.1,12.5,679.6,E,0.0,4.2,2025-04-10T19:00
E3,4.0,16.4,0.0,NE,0.0,1.1,2025-04-10T19:00
E4,3.6,16.8,1.6,SW,0.0,1.0,2025-04-10T19:00

jogadores.csv
Id,Nome,Posicao,Idade,Clube
1,Lionel Messi,Avançado,37,Inter Miami
2,Cristiano Ronaldo,Avançado,40,Al-Nassr
3,Kevin De Bruyne,Médio,33,Man City
4,Virgil van Dijk,Defesa,33,Liverpool
5,Kylian Mbappé,Avançado,26,Real Madrid
6,Bruno Fernandes,Médio,30,Man United
7,Erling Haaland,Avançado,25,Man City
8,Luka Modric,Médio,39,Real Madrid
9,Rafael Leão,Avançado,25,AC Milan

estatisticas.csv
Id,Golos,Assistencias,Jogos,Minutos
1,18,14,25,2120
2,23,7,27,2310
3,9,16,22,1980
4,3,2,24,2150
5,29,12,26,2210
6,11,13,25,2100
7,32,5,26,2300
8,4,10,23,2050
9,15,6,24,2090

-------------------------------------
pasta input 

exemplo.fca
-- A. Configuração de tabelas de dados
IMPORT TABLE estacoes FROM "data/estacoes.csv";
IMPORT TABLE observacoes FROM "data/observacoes.csv";
PRINT TABLE estacoes;
PRINT TABLE observacoes;
EXPORT TABLE estacoes AS "saida/est.csv";
RENAME TABLE estacoes est;
PRINT TABLE est;

-- B. Execução de queries sobre tabelas de dados
SELECT * FROM observacoes;
SELECT DataHoraObservacao, Id FROM observacoes;
SELECT * FROM observacoes WHERE Temperatura > 22;
SELECT * FROM observacoes WHERE Temperatura < 22 AND Radiacao > 600;
SELECT * FROM observacoes LIMIT 2;

-- C. Criação de novas tabelas de dados e -- D. procedimentos
CREATE TABLE mais_quentes SELECT * FROM observacoes WHERE Temperatura > 15;

PROCEDURE atualizar_observacoes DO
  CREATE TABLE completo FROM est JOIN observacoes USING(Id);
  PRINT TABLE completo;
END

CALL atualizar_observacoes;

-- Descartar Tabelas
DISCARD TABLE observacoes;
DISCARD TABLE est;
DISCARD TABLE completo;
DISCARD TABLE mais_quentes;

-- E. Comentários
{-
Os comentários apenas de uma linha são precedidos por -- (todo o texto seguinte é ignorado).
-}

exemplo2.fca
IMPORT TABLE jogadores FROM "jogadores.csv";
IMPORT TABLE estatisticas FROM "estatisticas.csv";

PRINT TABLE jogadores;
PRINT TABLE estatisticas;

SELECT Nome, Clube FROM jogadores WHERE Posicao = "Avançado";
SELECT * FROM estatisticas WHERE Golos > 20;

CREATE TABLE top_goleadores SELECT * FROM estatisticas WHERE Golos > 20;
PRINT TABLE top_goleadores;

CREATE TABLE resumo FROM jogadores JOIN estatisticas USING(Id);
PRINT TABLE resumo;

DISCARD TABLE jogadores;
DISCARD TABLE estatisticas;
DISCARD TABLE top_goleadores;
DISCARD TABLE resumo;
---------------------------
pasta saida

est.csv
Id,Local,Coordenadas
E1,Terras de Bouro/Barral (CIM),"[-8.31808611,41.70225278]"
E2,Graciosa / Serra das Fontes (DROTRH),"[-28.0038,39.0672]"
E3,"Olhão, EPPO","[-7.821,37.033]"
E4,"Setúbal, Areias","[-8.89066111,38.54846667]"
